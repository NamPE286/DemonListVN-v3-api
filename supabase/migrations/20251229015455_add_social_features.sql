-- Create posts table
create table "public"."posts" (
  "id" bigint generated by default as identity not null,
  "created_at" timestamp with time zone not null default now(),
  "updated_at" timestamp with time zone default now(),
  "authorId" uuid not null,
  "content" text not null,
  "imageUrl" text,
  "linkEmbed" text,
  "isDeleted" boolean not null default false,
  constraint "posts_pkey" primary key ("id")
);

alter table "public"."posts" enable row level security;

-- Create postLikes table
create table "public"."postLikes" (
  "created_at" timestamp with time zone not null default now(),
  "userId" uuid not null,
  "postId" bigint not null,
  constraint "postLikes_pkey" primary key ("userId", "postId")
);

alter table "public"."postLikes" enable row level security;

-- Create postComments table
create table "public"."postComments" (
  "id" bigint generated by default as identity not null,
  "created_at" timestamp with time zone not null default now(),
  "updated_at" timestamp with time zone default now(),
  "postId" bigint not null,
  "authorId" uuid not null,
  "content" text not null,
  "isDeleted" boolean not null default false,
  constraint "postComments_pkey" primary key ("id")
);

alter table "public"."postComments" enable row level security;

-- Create postReposts table
create table "public"."postReposts" (
  "id" bigint generated by default as identity not null,
  "created_at" timestamp with time zone not null default now(),
  "userId" uuid not null,
  "postId" bigint not null,
  constraint "postReposts_pkey" primary key ("id"),
  constraint "postReposts_unique" unique ("userId", "postId")
);

alter table "public"."postReposts" enable row level security;

-- Create userFollows table
create table "public"."userFollows" (
  "created_at" timestamp with time zone not null default now(),
  "followerId" uuid not null,
  "followingId" uuid not null,
  constraint "userFollows_pkey" primary key ("followerId", "followingId")
);

alter table "public"."userFollows" enable row level security;

-- Add foreign key constraints
alter table "public"."posts"
  add constraint "posts_authorId_fkey" 
  foreign key ("authorId") 
  references "public"."players"("uid") 
  on delete cascade;

alter table "public"."postLikes"
  add constraint "postLikes_userId_fkey" 
  foreign key ("userId") 
  references "public"."players"("uid") 
  on delete cascade;

alter table "public"."postLikes"
  add constraint "postLikes_postId_fkey" 
  foreign key ("postId") 
  references "public"."posts"("id") 
  on delete cascade;

alter table "public"."postComments"
  add constraint "postComments_postId_fkey" 
  foreign key ("postId") 
  references "public"."posts"("id") 
  on delete cascade;

alter table "public"."postComments"
  add constraint "postComments_authorId_fkey" 
  foreign key ("authorId") 
  references "public"."players"("uid") 
  on delete cascade;

alter table "public"."postReposts"
  add constraint "postReposts_userId_fkey" 
  foreign key ("userId") 
  references "public"."players"("uid") 
  on delete cascade;

alter table "public"."postReposts"
  add constraint "postReposts_postId_fkey" 
  foreign key ("postId") 
  references "public"."posts"("id") 
  on delete cascade;

alter table "public"."userFollows"
  add constraint "userFollows_followerId_fkey" 
  foreign key ("followerId") 
  references "public"."players"("uid") 
  on delete cascade;

alter table "public"."userFollows"
  add constraint "userFollows_followingId_fkey" 
  foreign key ("followingId") 
  references "public"."players"("uid") 
  on delete cascade;

-- Prevent users from following themselves
alter table "public"."userFollows"
  add constraint "userFollows_no_self_follow" 
  check ("followerId" != "followingId");

-- Create indexes for better query performance
create index "posts_authorId_idx" on "public"."posts" using btree ("authorId");
create index "posts_created_at_idx" on "public"."posts" using btree ("created_at" desc);
create index "postLikes_postId_idx" on "public"."postLikes" using btree ("postId");
create index "postComments_postId_idx" on "public"."postComments" using btree ("postId");
create index "postReposts_postId_idx" on "public"."postReposts" using btree ("postId");
create index "postReposts_userId_idx" on "public"."postReposts" using btree ("userId");
create index "userFollows_followerId_idx" on "public"."userFollows" using btree ("followerId");
create index "userFollows_followingId_idx" on "public"."userFollows" using btree ("followingId");

-- Create RLS policies (allow all for now, can be restricted later)
create policy "Enable read access for all users" on "public"."posts"
  for select using (not "isDeleted");

create policy "Enable insert for authenticated users" on "public"."posts"
  for insert with check (auth.uid()::text = "authorId");

create policy "Enable update for post authors" on "public"."posts"
  for update using (auth.uid()::text = "authorId" and not "isDeleted");

create policy "Enable delete for post authors" on "public"."posts"
  for delete using (auth.uid()::text = "authorId");

create policy "Enable read access for all users" on "public"."postLikes"
  for select using (true);

create policy "Enable insert for authenticated users" on "public"."postLikes"
  for insert with check (auth.uid()::text = "userId");

create policy "Enable delete for like owners" on "public"."postLikes"
  for delete using (auth.uid()::text = "userId");

create policy "Enable read access for all users" on "public"."postComments"
  for select using (not "isDeleted");

create policy "Enable insert for authenticated users" on "public"."postComments"
  for insert with check (auth.uid()::text = "authorId");

create policy "Enable update for comment authors" on "public"."postComments"
  for update using (auth.uid()::text = "authorId" and not "isDeleted");

create policy "Enable delete for comment authors" on "public"."postComments"
  for delete using (auth.uid()::text = "authorId");

create policy "Enable read access for all users" on "public"."postReposts"
  for select using (true);

create policy "Enable insert for authenticated users" on "public"."postReposts"
  for insert with check (auth.uid()::text = "userId");

create policy "Enable delete for repost owners" on "public"."postReposts"
  for delete using (auth.uid()::text = "userId");

create policy "Enable read access for all users" on "public"."userFollows"
  for select using (true);

create policy "Enable insert for authenticated users" on "public"."userFollows"
  for insert with check (auth.uid()::text = "followerId");

create policy "Enable delete for followers" on "public"."userFollows"
  for delete using (auth.uid()::text = "followerId");
